---
// Schedule.astro - Interactive calendar component
---

<div class="Schedule">
        <aside class="info">
            <div class="dates">
                <div class="reset interface">Today</div>
                <div class="date"></div>
                <div class="year"></div>
            </div>
            <div class="event-flex">
                <div class="event-title">Events</div>
                <div class="events"></div>
            </div>
            <div class="overlay"></div>
        </aside>
        <div class="grid">
            <nav>
                <div class="arrow left interface">⯇</div>
                <div class="month">March</div>
                <div class="arrow right interface">⯈</div>
            </nav>
            <div class="day name">SUN</div>
            <div class="day name">MON</div>
            <div class="day name">TUE</div>
            <div class="day name">WED</div>
            <div class="day name">THU</div>
            <div class="day name">FRI</div>
            <div class="day name">SAT</div>
        </div>
    </div>

<style is:global>
/* Flex container */
.flex-container {
    display: flex;
}

/* Overlay styles */
.overlay {
    /* Format */
    width: 100%;
    height: 100%;
    position: absolute;
    left: 0;
    top: 0;

    /* Style */
    background-image: linear-gradient(90deg,rgba(0,0,0,.9),rgba(100, 100, 100, 0.2));
    z-index: 2;
}

.Schedule {
    display: grid;
    grid-template-columns: 2fr 3fr;
    margin-inline: auto;
    max-width: 1150px;
    max-height: 70vh;
    border-radius: 2rem;
    overflow: hidden;
    margin-block: 2rem;
}

/* Information section within the schedule */
.Schedule .info {
    background: linear-gradient(var(--main-blue), #122940 );
    background-position: center;
    background-size: cover;
    position: relative;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
}

.Schedule .info::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-image: url(/assets/thumbnail.webp);
    background-size: cover;
    background-position: center;
    filter: grayscale(100%) contrast(100%);
    background-blend-mode: luminosity; 
    opacity: 0.1;
    z-index: 1;
}


/* Date section within the schedule */
.Schedule .dates {
    position: relative;
    display: flex;
    justify-content: space-between;
    color: var(--off-white);
    font-size: 1.2rem;
    padding: 1.5vh 2vh;
    z-index: 3;
    text-transform: uppercase;
    font-weight: 600;
}

/* Events section within the schedule */
.Schedule .events {
    color: var(--off-white);
    font-size: 150%;
    position: relative;
    text-align: center;
    z-index: 3;
}

/* Flex container for events */
.Schedule .event-flex {
    padding-block: 2vh;
    height: 80%;
    display: flex;
    flex-direction: column;
    position: relative;
    text-align: center;
    z-index: 3;
}

/* Individual event within the schedule */
.Schedule .event {
    padding-block: 2vh;
    background-color: rgba(0, 0, 0, 0.5);
}

/* Time section within events */
.Schedule .time {
    position: relative;
    color: var(--off-white);
    font-size: 50%;
    margin-inline: 1vw;
    z-index: 3;
    text-decoration: underline;
    text-underline-offset: 2px;
}

/* Title section within events */
.Schedule .event-title {
    text-transform: uppercase;
    font-weight: bold;
    position: relative;
    color: var(--off-white);
    font-size: 3rem;
    margin-inline: 1vw;
    z-index: 3;
    text-align: center;
    margin-block-end: 2vh;
}

/* Style for last month within calendar */
.Schedule .lastMonth {
    background-color: #173c626c !important;
    opacity: 80%;
}

/* Grid container for days within calendar */
.Schedule .grid {
    display: grid;
    grid-template: repeat(8,1fr) / repeat(7,1fr);
    padding: 1%;
}

/* Name styling within calendar */
.Schedule .name {
    font-weight: 1000;
    user-select: none;
}

/* Individual day styling within calendar */
.Schedule .grid .day {
    padding: 1vh;
    border-radius: 5rem;
    transition: .5s;
    margin: 1vh;
    display: grid;
    align-items: center;
    text-align: center;
}

/* Hover effect on individual day */
.Schedule .day.interface:hover {
    background-color: var(--main-blue) !important;
    color: var(--off-white) !important;
}

/* Opacity effect on non-hovered days when calendar is hovered */
.Schedule .grid:has(:hover) .day.interface:not(:hover,.selected) {
    opacity: .5;
}

/* Navigation styling within calendar */
.Schedule nav {
    display: grid;
    grid-column: 1/-1;
    grid-template-columns: 1fr 1fr 1fr;
    place-items: center;
    font-size: 1.5rem;
    font-weight: bold;
    text-transform: uppercase;
}

/* Selected day styling within calendar */
.Schedule .selected {
    background-color: var(--main-blue) !important;
    color: var(--off-white) !important;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
}

/* Interface styling for calendar days */
.Schedule .interface {
    cursor: pointer;
    user-select: none;
    font-weight: bold;
}

/* Reset button styling within calendar */
.Schedule .reset {
    position: relative;
    border: var(--off-white) solid 1px;
    border-radius: 4px;
    padding: .3rem;
    padding-inline-start: .5rem;
    font-size: .8rem;
    color: var(--off-white);
    z-index: 3;
    opacity: 80%;
    transition: 1s;
    height: min-content;
    border-top-left-radius: 1rem;
}

/* Hover effect on reset button */
.Schedule .reset:hover {
    opacity: 100%;
}

/* ==================== Section: Event Dots ==================== */
 
.event-dot-container {
    display: flex;
    flex-direction: row;
    place-self: center;
    gap: .25vw;
}

.event-dot {
    width: 10px; /* Size of the dot */
    height: 10px;
    border-radius: 50%; /* Make it round */
}

/* ==================== Section: Responsive ==================== */

/* Responsive styles for smaller screens */
@media only screen and (max-width: 1199px) {
    /* Adjust grid layout for smaller screens */
    .Schedule {
        grid-template-columns: 1fr;
        grid-template-rows: 1fr 1fr;
        max-height: 120vh;
        border-radius: 0rem;
    }

    /* Adjust day styling for smaller screens */
    .Schedule .grid .day {
        padding: 0vh;
        border-radius: 5rem;
        transition: .5s;
        margin: 1vw;
        display: grid;
        align-items: center;
        text-align: center;
    }

    /* Adjust reset button styling for smaller screens */
    .Schedule .reset {
        border-top-left-radius: 0rem;
        padding-inline-start: 0.3rem;
    }
}

@media only screen and (max-width: 950px) {
    .location-pin:nth-child(1){
        display: none;
    }
    .location-pin:nth-child(2){
        display: none;
    }
    .location-pin:nth-child(3){
        display: none;
    }
    .location-pin:nth-child(4){
        display: block;
        margin: 0;
        padding: 0;
        padding-inline: 0;
        padding-block: 0;
    }

    .location-pin:nth-child(4) *{
        background-color: white;
        width: 34px;
        height: 34px;
        position: relative;
        object-fit:contain;
    }
}
</style>

<script>
function createDiv(classes, content) {
    const div = document.createElement('div');
    div.classList.add(...classes);
    div.textContent = content;
    return div;
}

// Calendar class responsible for handling calendar-related functionalities
class Calendar {
    // Static properties to store selected date, month, year, and event data
    static selectedDate = new Date();
    static weekDay = this.selectedDate.getDay();
    static day = this.selectedDate.getDate();
    static month = this.selectedDate.getMonth();
    static year = this.selectedDate.getFullYear();
    static time = this.selectedDate.getHours();
    static months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

    static events = [
        { date: '2024-12-06', repeats: true, frequency: 'weekly', color: '#fea655', events: [['Canvassing', '10:00am - 2:00pm']] },
    ];

    // Method to handle selecting a day on the calendar
    static selectDay(element) {
        // Remove selected class from all days and add it to the clicked day
        UI.days.forEach(day => {
            if (day.classList.contains('selected')) day.classList.remove('selected', 'Grit');
        });
        element.classList.add('selected', 'Grit');
        this.day = parseInt(element.textContent);
        // Update selected date
        this.selectedDate = new Date(this.year, this.month, this.day);
        // If the clicked day belongs to the last month, update selected date accordingly
        if (element.classList.contains('lastMonth')) {
            this.selectedDate = new Date(this.year, this.month - 1, this.day);
            this.lastMonth();
        }
        // Update calendar info based on the selected date
        this.updateInfo();
    }

    // Method to navigate to the next month
    static nextMonth() {
        UI.update();
        UI.days.forEach(day => {
            day.remove();
        });
        this.month++;
        if (this.month > 11) {
            this.month = 0;
            this.year++;
        }
        Calendar.generate(this.year, this.month);
    }

    // Method to navigate to the previous month
    static lastMonth() {
        UI.update();
        UI.days.forEach(day => {
            day.remove();
        });
        this.month--;
        if (this.month < 0) {
            this.month = 11;
            this.year--;
        }
        Calendar.generate(this.year, this.month);
    }

    // Method to reset calendar to the current date
    static reset() {
        this.selectedDate = new Date();
        this.day = this.selectedDate.getDate();
        this.month = this.selectedDate.getMonth();
        this.year = this.selectedDate.getFullYear();
        UI.update();
        UI.days.forEach(day => {
            day.remove();
        });
        this.generate(this.year, this.month);
    }

    // Method to update calendar information based on selected date
    static getEventsForDate(date) {
        const selectedDateString = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
        
        return this.events.filter(event => {
            const [year, month, day] = event.date.split("-");
            const eventDateString = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
            if (!event.repeats && eventDateString === selectedDateString) return true;
            
            // Handle repeating events
            if (event.repeats) {
                switch (event.frequency) {
                    case 'daily':
                        return true; // Always matches for daily events
                    case 'weekly':
                        return date.getDay() === parseInt(day - 1) % 7;
                    case 'monthly':
                        return date.getDate() == parseInt(day); // Match the day of the month
                    case 'yearly':
                        return (date.getDate() == parseInt(day) && date.getMonth() + 1 == parseInt(month)); // Match the day and month
                    case 'custom':
                        break;
                }
            }
        
            return false; // No match
        });
    }
    
    // Method to update calendar information based on selected date
    static updateInfo() {
        // Update calendar month, date, and year
        Display.change(Display.calendarMonth, this.months[this.month]);
        Display.change(Display.calendarDate, `${this.months[this.selectedDate.getMonth()]} ${this.selectedDate.getDate()}${["st", "nd", "rd"][((this.selectedDate.getDate() + 90) % 100 - 10) % 10 - 1] || "th"}`);
        Display.change(Display.calendarYear, this.selectedDate.getFullYear());
        Display.change(Display.calendarEvents, ''); // Clear existing events
    
        // Get events for the selected date
        const eventsForDate = this.getEventsForDate(this.selectedDate);
    
        // Append the events to the display
        eventsForDate.forEach(event => {
            event.events.forEach(([eventName, eventTime]) => {
                const eventDiv = createDiv(['event'], eventName);
                eventDiv.append(createDiv(['time'], eventTime));
                Display.calendarEvents.append(eventDiv);
            });
        });
    }

    // Method to generate calendar grid for a specific month
    static generate(year, month) {
        // Update calendar info
        this.updateInfo();
        const lastDayOfMonth = new Date(year, month + 1, 0).getDate();
        const lastDayOfLastMonth = new Date(year, month, 0).getDate();

        // Generate days for the month
        for (let i = 1; i < lastDayOfMonth + 1; i++) {
            const date = new Date(year, month, i);

            // If the date is the first day of the month, fill in previous month's days
            if (date.getDate() == 1) {
                for (let i = date.getDay() - 1; i > -1; i--) {
                    Display.calendarGrid.append(createDiv(['day', 'interface', 'lastMonth'], lastDayOfLastMonth - i));
                }
            }
            
            // Create the day element
            const dayDiv = createDiv(
                date.setHours(0, 0, 0, 0) == this.selectedDate.setHours(0, 0, 0, 0)
                ? ['selected', 'day', 'interface', 'Grit']
                : ['day', 'interface'],
                date.getDate()
            );

            const eventsForDay = this.getEventsForDate(date);
            const dotContainer = createDiv(['event-dot-container']);
            
            // If there are events, create dots
            if (eventsForDay.length > 0) {
                eventsForDay.forEach(event => {
                    let eventColor = event.color || 'white';
                    if (event.frequency === 'daily') {
                        return;
                    }
                    event.events.forEach(() => {
                        const dot = createDiv(['event-dot']);
                        dot.style.backgroundColor = eventColor;
                        dot.style.border = eventColor === 'white' ? '2px solid black' : 'none'; // Black outline if no color
                        
                        // Limit to 3 dots per day
                        if (dotContainer.childElementCount < 3) dotContainer.append(dot);
                    });
                });
            }

            // Append the day div to the calendar grid
            dayDiv.append(dotContainer);
            Display.calendarGrid.append(dayDiv);
        }
        UI.update();
    }
}

// UI class responsible for handling user interface interactions
class UI {
    static calendarMonthRight = document.querySelector('.Schedule .right.interface');
    static calendarMonthLeft = document.querySelector('.Schedule .left.interface');
    static days = document.querySelectorAll('.Schedule .day.interface');
    static reset = document.querySelector('.Schedule .reset.interface');
    static listenersAttached = false;

    // Method to initialize UI event listeners
    static initialize() {
        // Re-query elements
        this.calendarMonthRight = document.querySelector('.Schedule .right.interface');
        this.calendarMonthLeft = document.querySelector('.Schedule .left.interface');
        this.reset = document.querySelector('.Schedule .reset.interface');
        
        // Check if elements exist
        if (!this.calendarMonthRight || !this.calendarMonthLeft || !this.reset) {
            return;
        }

        // Prevent duplicate listeners
        if (!this.listenersAttached) {
            this.calendarMonthLeft.addEventListener('click', () => Calendar.lastMonth());
            this.calendarMonthRight.addEventListener('click', () => Calendar.nextMonth());
            this.reset.addEventListener('click', () => Calendar.reset());
            this.listenersAttached = true;
        }
    }

    // Method to update UI elements
    static update() {
        this.days = document.querySelectorAll('.Schedule .day.interface');
        this.days.forEach(day => {
            // Check if listener already attached to prevent duplicates
            if (!day.dataset.listenerAttached) {
                day.addEventListener('click', () => Calendar.selectDay(day));
                day.dataset.listenerAttached = 'true';
            }
        });
    }
}

// Display class responsible for handling display-related functionalities
class Display {
    static calendarGrid = document.querySelector('.Schedule .grid');
    static calendarMonth = document.querySelector('.Schedule .month');
    static calendarInfo = document.querySelector('.Schedule .info');
    static calendarDate = document.querySelector('.Schedule .date');
    static calendarYear = document.querySelector('.Schedule .year');
    static calendarEvents = document.querySelector('.Schedule .events');
    static calendarEvent = document.querySelector('.Schedule .events .event:last-child');
    static initialized = false;

    // Method to change content of an element
    static change(element, content) {
        element.textContent = content;
    }

    // Method to update display elements
    static update() {
        this.calendarEvent = document.querySelector('.Schedule .events .event:last-child');
    }
    
    // Method to refresh all DOM references
    static refresh() {
        this.calendarGrid = document.querySelector('.Schedule .grid');
        this.calendarMonth = document.querySelector('.Schedule .month');
        this.calendarInfo = document.querySelector('.Schedule .info');
        this.calendarDate = document.querySelector('.Schedule .date');
        this.calendarYear = document.querySelector('.Schedule .year');
        this.calendarEvents = document.querySelector('.Schedule .events');
        this.calendarEvent = document.querySelector('.Schedule .events .event:last-child');
    }
}

// --- SETUP FUNCTION ---
function initializeCalendar() {
    // Refresh all DOM references after navigation
    Display.refresh();
    
    // Check if calendar elements exist on this page
    if (!Display.calendarGrid) {
        return; // Calendar not on this page
    }
    
    // Prevent double initialization
    if (Display.initialized) {
        return;
    }
    
    Display.initialized = true;
    
    // Reset listener flag for navigation controls
    UI.listenersAttached = false;
    
    // Generate initial calendar for current month
    Calendar.generate(Calendar.year, Calendar.month);
    
    // Initialize UI event listeners
    UI.initialize();
}

// --- Astro View Transitions Handling ---

// Only use astro:page-load, which fires on both initial load AND navigation
document.addEventListener('astro:page-load', () => {
    // Reset the initialization flag on each page load
    Display.initialized = false;
    initializeCalendar();
});
</script>